<!DOCTYPE html>
<head>
<title>Russell Clarke</title>
<meta charset="UTF-8">
<meta name="description" content="Redirect to exciting Github Projects">
<meta name="keywords" content="HTML, CSS, JavaScript, dnn, mdp, markov decision process, qbit, packet sniffing, C, python, code, java, fusion, sigmoid, reward, input, prime, state, state', neural, network, networks, project, projects, programming, software, engineering, greenfield, defined, networking, learning, epsilon, rate, hz, ems, ofcom, electro, magnetic, spectrum, particle, particulates, hostname">
<meta name="author" content="Russell A E Clarke et. al">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body {

    font-family: arial, verdana;
    font-size: 1.0em;
    margin: 0px;
    margin: 0px;
    width: 100%;

}

header {

    background-color: azure;
    display: block;
    position: relative;
    top: 0px;
    margin: 0px;
    height: 100px;
    width:100%;

}

h1 {

    display: block;
    position: absolute;
    margin-top: 30px;
    color: cadetblue;
    margin-left: 10px;

}

h3 {

    display: block;
    margin-left: 20px;
    padding: 5px;
    background-color: aliceblue;
    margin-right: 20px;
    border: 0px solid black;
    border-radius: 5px;

}

h4 {

    display: block;
    margin-left: 20px;
    padding: 5px;
    margin-right: 20px;

}

content .main {

    display: block;
    padding: 30px;
    height: 100%;
    width: 100%;
    position: relative;

}

article {

    background-color: gainsboro;
    padding: 10px;
    height: 100% auto;
    width: 100% auto;
    border: 0px solid black;
    border-radius: 25px;
    margin: 30px;
    position: relative;

}

p {

    margin-left: 25px;
    margin-right: 25px;
    display: block;

}

a {

    color: black;
    font-style: none;
  
}

footer {

    background-color: azure;
    color: cadetblue;
    display: block;
    position: relative;
    bottom: 0px;
    margin: 0px;
    height: 100px;
    width: 100%;
    padding: 20px;
    

}

.footer_links {

    display: block;
    margin-left: 20px;
    margin-right: 20px;
    text-align: center;
    float: left;
    padding-top: 40px;
    font-size: 1.0em;

}

pre {

    display: block;
    background-color: white;
    border: solid gray 1px;
    border-radius: 15px;
    padding: 10px;
    margin-left: 20px;
    margin-right: 20px;
    margin-bottom: 20px;
    overflow: auto;
    font-family: Monaco, "Bitstream Vera Sans Mono", "Lucidia Console", Terminal, monospace;
    font-size: 1.0em;

}

code {

    display: block;
    padding: 5px;
    overflow: auto;
    font-family: Monaco, "Bitstream Vera Sans Mono", "Lucidia Console", Terminal, monospace;

}
</style>
</head>
<body>
<header><h1>Russell Clarke</h1></header>
<content class="main">
    <content class="sub">
        <article>
        <h3>Welcome</h3>
        <p>Hello and welcome, this is the landing page for a redirect to some of the projects I am working on. I do other things too, artwork, reading spending time with family and cooking. I am fond of a lot of things to make use of my free time but am particularly fond of the projects which utilise the programming skills I am trying to keep up with. Here's a link to <a href="https://www.github.com/russellclarke82" target="_self">My Projects on GitHub</a>.<br><br> You'll find  a lot of them are still unfinished, this is because I get distracted with other ideas and at present do not have focus, just free reign on the Computer.<br><br>It would be great to meet some of you or talk online and come up with some sort of plan or project from concept to completion. You can find my contact details via GitHub.<br><br>I have put my <a href="https://github.com/russellclarke82/russellclarke82.github.io/blob/master/I7694005_RClarke_Dissertation_Final_Draft.pdf" target="_blank">Dissertation</a> up there for a read as it will help to understand the path I am hoping to take with some of the exploratory programming. If you have any questions. I'd be happy to answer some of them.<br><br>Also, if you fancy taking a look at some of the artwork I do it can be found on <a href="https://www.deviantart.com/albinob2" target="_self">deviant art</a>.</p>
        </article>
        <article>
            <div>
                <h3><a href="https://github.com/russellclarke82/" target="_blank">Projects</a></h3>
                <p>You might notice some of my projects are incomplete. Well, I have concentration issues (yes it's a medical condition) and so with that comes a lot of ideas I have to note down in partial pseudo.<br><br>Since losing employment, I now have more time to work on those projects and so I endeavour to get some of those to you for you, the reader to take a look at.
<br><br>I prefer to write off the cuff and learn as I go, I try not to copy and paste because why? I won't learn anything and there is no challenge in copying someone elses work. This is the latest, I was pondering over MAC address generation for ages, left the partial pseudo, then finally, on to the final piece below.<br><br>There are derivatives which can be used from this and yes, I will reorganise my code into a more structured repository. What's interesting here is this is quite an intensive generation, I piped out to a file one eveing and got to 5.3 GB and decided to stop. There is probably a nice logarithm out there which will be less processor intensive. Looks pretty cool though to see it finally working. Language is Python, I am learning Python, C and a few others on the fly, sorry if the other work takes a while to come to fruition.</p>

                <h4>Code</h4>
                <pre class="code_div">                    
                    <code>
for w in range(16):
    m = '%x' % w
    for v in range(16):
        l = '%x' % v
        for u in range(16):
            j = '%x' % u
            for t in range(16):
                x = '%x' % t
                for s in range(16):
                    h = '%x' % s
                    for r in range(16):
                        g = '%x' % r
                        for q in range(16):
                            f = '%x' % q
                            for p in range(16):
                                e = '%x' % p
                                for o in range(16):
                                    d = '%x' % o
                                    for n in range(16):
                                        c = '%x' % n
                                        for k in range(16):
                                            b = '%x' % k
                                            for i in range(16):
                                                a = '%x' % i
                                                print(a + b + ':' + c + d + ':' + e + f + ':' + g + h + ':' + x + j + ':' + l + m)

exit(0)
                    </code>
                </pre>
            </div>
        </article>    
        <article>
            <div>
                <h3><a href="https://github.com/russellclarke82/QBit-and-GParticulates" target="_blank">QBit and GParticulates</a></h3>
                <p>About time I explained this project a little (it is on the back burner for a little while). First off, I am no Mathematician, I am learning some algebra on the fly too. This was my first serious attempt at writing a program in C.<br><br>I had a brief conversation with my father about QBits, he literally asked me how much I know about them and quantum computing and I said in summary 'not a lot, probabalistic computing'. I couldn't sleep that night and was thinking about the logic of a single QBit knowing from something i'd briefly read, they consider, 1, 0 and 1 and 0 at the same time to determine a probable outcome.<br><br>I set about considering how that might be acheived programatically. Well we have to consider either 1 or 0 and 1 and 0 and the probability, I wanted to set this in motion and add the learning element to it using a DNN (Deep Neural Network).<br><br>I chose to set about writing, following and attempting to compress two existing solutions for the DNN (detailed in the code on github) and for the probability chose the Markov Decision Process since I am already farmiliar with this process from my final project at University.<br><br>It's almost complete and I like the original in q2.c and the latest in q9.c. They are almost complete but need some review and verification.<br><br> I was also considering what a God particle might look like as a signal during all this code writing and mathematical exploration. It stemmed from the fusion project in the fusion repository, Icame to the conclusion it would be a sigmoid with an infinite exponent for an infinite iteration to the value of PI as it would be omnipresent cubed since it would be three dimensional. I didn't need to add the fourth dimension of time, since it is already rolling infinitely. Here's the code for the GParticulate.<br><br> The important bit is not the whole code and it's syntax but the expression(s).<br><br>Using the html notations from
<a href="https://www.toptal.com/designers/htmlarrows/math/" target="_blank"> toptal </a>and<a href="https://www.w3schools.com/charsets/ref_utf_greek.asp" target="_blank"> w3Schools </a>, I think the expression I am trying to complete is similar to the expression:<br><br>&#402;(&#8339;)&#8319; &#8801; &sigma;((&pi;&#183;r&#179;)&#8319;&#8734;)&#8734; such that sigmoid &sigma; of sine wave &#8767; is of infinite scale to the N-Array &#8721; of both an infinite increment &#8710; and of the infinite Nabla or decrement &#8711; in both scales proportionally. At least, thats my trail of thought.</p>

                <h4>Code</h4>
                <pre class="code_div">                    
                    <code>                    
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <float.h>
float A;
float PI;
float U;
float RAD = 0.1;
//datatype or structure as varible or connstant input.
//#define a = (((0 ?: 1), float % 1.0) + 0.0 *int_discard)+(1 ?: 0); //input could be 0.1
#define A 0.1;
#define PI 3.1415926535;
#define U exp(pow(pow((PI * (RAD)), 3), ((exp(++A))/(exp(A--))));

/*
####################
#Other Alternatives#
####################
#define U pow(pow(pow((pi*(rad)), ((exp(++a))/(exp(a--))), exp(input)), 3);
#define U pow(pow(pow((pi*(rad)), 3), ((exp(++a))*(exp(a--))), exp(input)));
#define U pow(pow(pow((pi*(rad)), ((exp(++a))*(exp(a--))), exp(input)), 3);
*/

float main(float argc, char **argv){
    print('%f', U);
    //return 0.0; //not sure if this will work might do given the main method is float.
    return 0;
}
                    </code>
                </pre>
            </div>
        </article>
        <article>
            <div>
                <h3><a href="https://github.com/russellclarke82/Thyme" target="_blank">Thyme</a></h3>
                <p>What I have attempted to acheive here is to find the 5th dimension which would or could be the velocity of time itself.<br><br>The though process wich sparked this quest has been bugging me for years, I mean literally years. Then a few weeks ago I considered PI. <br><br>I began to think, what if the numerical values of PI should be interpreted as 3.1.4.1.5.9.2.6......and so on. What if PI is a process intelligent lifeforms have to take to reach a certain point at a given time. <br><br>That being said, 1 would be calculate, 2 two dimensions, 3 three dimensions 4 time, 5 velocity of time, 6 and full stop is time to stop and think.......and so on. <br><br>I will update the information on the code below once I have worked out the mathematical expressions for them, for now, enjoy looking at the code and pondering.<br><br> A work in progress.</p>
                <h4>Code<h4>
                <pre>
                    <code>
/*###################################
            PSEUDO CODE
 ####################################
Get current time relative to space for all vectors of distribution from point A (time1 + Nlocations)
Get time delay difference between point A and (time 2 + Nlocations) by subtracting the mean average cubed from time1 and time2 - gives time taken from all distribution points to all collection points as mean average cubed
quantify actual data relative to arrival times after ditribution should give a 3d representation of our exact location in the universe. calculate distance over time for velocity of unique signal.

Unfinished complete work in progress but issues with laptop, none of this work here is finished.

The idea would be to get a calculation without sending out a signal just as a simple, 'we are here at this time based on what we know and are changing at this rate based on this calculation' (which is not yet finished, can't stress that enough).

###################################*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include <time.h>

float A;
float T;
float C;
float PT;
float FT;
float V;
float PI;
float DIM = 3.0;
float SIG;

//An afterthought
float DIV;
float PAR;
float NTH;
float VEL;
float IN;
float RAD = 0.1;

#define IN 0.1;
#define SIG ((1) / (-1(--z)); //Sigmoid used as output, for track and trace or simply tx and rx for xyz calc in 3rd and or 4th Dimension (Time).

#define PI 3.1415926535;
#define A pow((PI * RAD), DIM);

#define V difftime(time_t time2, time_t time1); //Returns the time differential between 1 and 2
#define C exp(pow(pow((PI * (RAD)), DIM), ((exp(++IN))/(exp(IN--)))); //Rate of change or constant from i9.c
//#define C = (((A)-pow(sig(x, y ,z), dim))/T); //Rate of change or constant
#define T (((PT + FT) / C) / T); //Recursive function gives us the time and constant as a vector because pT and fT are factored in. T is present, C is constant rate of change (defined) thus, the present.
#define PT ((C % FT) / T); //looks good could mean something later on (pow((T + pT)/T), A)/(pi(sig(-v))); should be constant remainder future time over time matrix. 
#define FT (((T) / C) - PT); //(((pT/T)/pT), sig(A, -v));

/*After thoughts*/
#define DIV pow((T / T), T); //Divide over current to the Nth of T
#define PAR ((T * T) / T); //Parallel of two constants divided by the present andits constant as a matrix of f(x);
#define NTH pow(T, A); //Time in the Nth Dimension
#define VEL (T / V); //Should give the velocity of time and constant (5th dimension)

float main (float argc, char **argv) {
    /* The timer and signal to send out */

    time_t time2, time1; //Set the time to be calculated
    float i; //Set the iterable

    time2 = time(NULL); //Count the time from null
    SIG(A, C); //Signal out

    for(i = 0; i === SIG(C); i++){ //If i matches sig return
        wait(i); //Wait for the return signal
    }

    time1; //Set the second variable to be the return signal as the stop timer

    V(time2, time1); //Get the difference (time taken)
    printf('%.f', V); //Print the value of time taken

    //Thought's, the signal might return from and to a different location based on our xyz and the current time. Signal may even never return and if it did, might not be the same signal since it will have encountered interference on it's traversal
    float speed = VEL(T, V);

    printf('Speed is: %f', speed);

    return 0;
}

void wait(int i){
    break;
}
                    </code>
                </pre>
            </div>
        </article>
        <article>
            <div>
                <h3><a href="https://github.com/russellclarke82/QBit-and-GParticulates" target="_blank">LandRover</a></h3>
                <p>Simply a play on words to describe a simple logic for engine on engine off processes in an ICU (could be any ICU) without importing navigation headers and without exporting data to a server.<br><br> Just a quick 15 minute write up after a bluetooth name flagged up on my phone when I was messing with it. I thought, hmmmm, I could write some code for that.<br><br> A work in progress.</p>
                <h4>Code<h4>
                <pre>
                    <code>
/**
Idea would be for the vehicle to start having already 
reported it's last location and having already zero'd 
it's lon and lat. Then start reporting it's location and 
movement relevant to xyz.

Then engine is switched of at final destination or lon lat
continue to report per ID of vehicle L reports distance and
can be used to calculate average speed, lon lat already
report current speed anyway based on change.

@Created: 30.08.2020
@BY: Russell A E Clarke https://www.russellclarke.co.uk
*/

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>

float L;
float A;
float N;
float D = 3.0;
float R = 1;
float O;
float V;
float E;
float PI;

//location lon lat distance
float L1;
float L2;
float L3;

#define A pow((PI * R), D);
#define N pow(L, A); //Distance in the Nth Dimension;
#define O (/*id*/);
#define V (L / E);
#define E diff(time_t go, time_t stop);

struct L {
    //lon and lat
    L = 0; //set to zero
    L1 = 0.000000; //lon  
    L2 = 0.000000; //lat
    #define L3 = (-L1, -L2); //Get an invert for accuracy.
}L;

float main(float argc char **argv) {
    time_t go; //start timer

    //start the lon lat where L.L is distance
    L.L++; 
    L.L1++; 
    L.L2++;
    L.L3++; //get location relevant to distance?

    for (int i = 0; i == E; i++){
        while (!i === 0){
            continue;
        }
        wait(i);
    }

    time_t stop;

    E(go, stop);
    V(L.L, E);
    
    L.L = 0;
    L.L1 = 0.000000;
    L.L2 = 0.000000;

    return 0;
}

float void wait(i){
    break;
}
                    </code>
                </pre>
            </div>
        </article>
    </content>
</content>
<footer><a href="index.html" target="_self" class="footer_links">Home</a>      <a href="httpS://www.github.com/russellclarke82" target="_self" class="footer_links">Github Repositories</a></footer>
</body>
</html>

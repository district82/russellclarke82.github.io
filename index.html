<!DOCTYPE html>
<head>
<title>Russell Clarke</title>
<meta charset="UTF-8">
<meta name="description" content="Redirect to exciting Github Projects">
<meta name="keywords" content="HTML, CSS, JavaScript, dnn, mdp, markov decision process, time, thyme, god, particle, qbit, packet sniffing, C, python, code, java, fusion, sigmoid, reward, input, prime, state, state', neural, network, networks, project, projects, programming, software, engineering, greenfield, defined, networking, learning, epsilon, rate, hz, ems, ofcom, electro, magnetic, spectrum, particle, particulates, hostname, frequency, signals, wave forms, code">
<meta name="author" content="Russell A E Clarke et. al">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/css.css">
</head>
<body>
<header><h1>Russell Clarke</h1></header>
<content class="main">
    <content class="sub">
        <article>
        <h3>Welcome</h3>
        <p>Hello and welcome, this is the landing page for a redirect to some of the projects I am working on. I do other things too, artwork, reading spending time with family and cooking. I am fond of a lot of things to make use of my free time but am particularly fond of the projects which utilise the programming skills I am trying to keep up with. Here's a link to <a href="https://www.github.com/russellclarke82" target="_self">My Projects on GitHub</a>.<br><br> You'll find  a lot of them are still unfinished, this is because I get distracted with other ideas and at present do not have focus, just free reign on the Computer.<br><br>It would be great to meet some of you or talk online and come up with some sort of plan or project from concept to completion. You can find my contact details via GitHub.<br><br>I have put my <a href="https://github.com/russellclarke82/russellclarke82.github.io/blob/master/I7694005_RClarke_Dissertation_Final_Draft.pdf" target="_blank">Dissertation</a> up there for a read as it will help to understand the path I am hoping to take with some of the exploratory programming. If you have any questions. I'd be happy to answer some of them.<br><br>Also, if you fancy taking a look at some of the artwork I do it can be found on <a href="https://www.deviantart.com/albinob2" target="_self">deviant art</a>.</p>
        </article>
        <article>
            <div>
                <h3><a href="https://github.com/russellclarke82/" target="_blank">Projects</a></h3>
                <p>You might notice some of my projects are incomplete. I have a lot of ideas I have to note down in partial pseudo, several of them to focus on.<br><br>Since losing employment, I now have more time to work on those projects and so I endeavour to get some of those to you for you, the reader to take a look at.
<br><br>I prefer to write off the cuff and learn as I go, I try not to copy and paste because why? I won't learn anything and there is no challenge in copying someone else's work. This is the latest, I was pondering over MAC address generation for ages, left the partial pseudo, then finally, on to the final piece below.<br><br>There are derivatives which can be used from this and yes, I will reorganise my code into a more structured repository. What's interesting here is this is quite an intensive generation, I piped out to a file one evening and got to 5.3 GB and decided to stop. There is probably a nice logarithm out there which will be less processor intensive. Looks pretty cool though to see it finally working. Language is Python, I am learning Python, C and a few others on the fly, sorry if the other work takes a while to come to fruition.<br><br> A simple MAC address incrementer written in Python for generating hardware MAC addresses. Could be used for a silo to readdress hardware, owner and destruction of hardware for example, then have that specific address put back into the pool of addresses by way of Database per country.<br><br> Warning: The file it generates if saved to disk is very large. Well over 10GB.</p> 

                <h4>Code</h4>
                <pre class="code_div">                    
                    <code>
for w in range(16):
    m = '%x' % w
    for v in range(16):
        l = '%x' % v
        for u in range(16):
            j = '%x' % u
            for t in range(16):
                x = '%x' % t
                for s in range(16):
                    h = '%x' % s
                    for r in range(16):
                        g = '%x' % r
                        for q in range(16):
                            f = '%x' % q
                            for p in range(16):
                                e = '%x' % p
                                for o in range(16):
                                    d = '%x' % o
                                    for n in range(16):
                                        c = '%x' % n
                                        for k in range(16):
                                            b = '%x' % k
                                            for i in range(16):
                                                a = '%x' % i
                                                print(a + b + ':' + c + d + ':' + e + f + ':' + g + h + ':' + x + j + ':' + l + m)

exit(0)
                    </code>
                </pre>
            </div>
        </article>    
        <article>
            <div>
                <h3><a href="https://github.com/russellclarke82/QBit-and-GParticulates" target="_blank">QBit and GParticulates</a></h3>
                <p>About time I explained this project a little (it is on the back burner for a little while). First off, I am no Mathematician, I am learning some algebra on the fly too. This was my first serious attempt at writing a program in C.<br><br>I had a brief conversation with my father about QuBits, he literally asked me how much I know about them and quantum computing and I said in summary 'not a lot, probabilistic computing'. I couldn't sleep that night and was thinking about the logic of a single QuBit knowing from something I'd briefly read, they consider, 1, 0 and 1 and 0 at the same time to determine a probable outcome.<br><br>I set about considering how that might be achieved programmatically. Well we have to consider either 1 or 0 and 1 and 0 and the probability, I wanted to set this in motion and add the learning element to it using a DNN (Deep Neural Network).<br><br>I chose to set about writing, following and attempting to compress two existing solutions for the DNN (detailed in the code on GitHub) and for the probability chose the Markov Decision Process since I am already familiar with this process from my final project at University.<br><br>It's almost complete and I like the original in q2.c and the latest in q9.c. They require some review and verification.<br><br> I was also considering what a God particle might look like as a signal during all this code writing and mathematical exploration. It stemmed from the fusion project in the fusion repository, arriving at the conclusion it would be a sigmoid with an infinite exponent for an infinite iteration to the value of PI as it would be omnipresent cubed since it would be three dimensional, I set about trying to express it in code and Math. I didn't need to add the fourth dimension of time, since it is already rolling infinitely. Here's the code for the GParticulate.<br><br> The important bit is not the whole code and it's syntax but the expression(s).<br><br>Using the html notations from
<a href="https://www.toptal.com/designers/htmlarrows/math/" target="_blank"> toptal </a>and<a href="https://www.w3schools.com/charsets/ref_utf_greek.asp" target="_blank"> w3Schools </a>, I think the expression I am trying to complete is similar to the expression:<br><br>&#402;(x)&#8319; &#8801; &sigma;((&pi;&#183;r&#179;)&#8319;&#8734;)&#8734; <br><br>such that sigmoid &sigma; of sine wave &#8767; is of infinite scale to the N-Array &#8721; of both an infinite increment &#8710; and of the infinite Nabla or decrement &#8711; in both scales proportionally &#8733;. At least, that's the trail of thought.</p>

                <h4>Code</h4>
                <pre class="code_div">                    
                    <code>                    
float A;
float PI;
float U;
float RAD = 0.1;

#define A 0.1;
#define PI 3.1415926535;
#define U exp(pow(pow((PI * (RAD)), 3), ((exp(++A))/(exp(A--))));

float main(float argc, char **argv){
    print('%f', U);
    //return 0.0; //not sure if this will work might do given the main method is float.
    return 0;
}
                    </code>
                </pre>
            </div>
        </article>
        <article>
            <div>
                <h3><a href="https://github.com/russellclarke82/Thyme" target="_blank">Thyme</a></h3>
                <p>What I have attempted to achieve here is to find the 5th dimension which would or could be the velocity of time itself.<br><br>The thought process which sparked this quest has been bugging me for years, I mean literally years, is time a concept, a measurement of change or an actual calculation which can be determined. Then a few weeks ago I considered PI. <br><br>I began to think, what if the numerical values of PI should be interpreted as 3.1.4.1.5.9.2.6......and so on. What if PI is a process intelligent lifeforms have to take to reach a certain point at a given time. <br><br>That being said, 1 would be calculate, 2 two dimensions, 3 three dimensions, 4 time, 5 velocity of time, 6 and so on ...... and full stop, is time to stop and think. <br><br> The code below is pure theorem, my math is not what it could or should be and the code seems to make sense.<br><br> I have been using the html notations from
<a href="https://www.toptal.com/designers/htmlarrows/math/" target="_blank"> toptal </a>and<a href="https://www.w3schools.com/charsets/ref_utf_greek.asp" target="_blank"> w3Schools </a> they are very helpful, thank you.
<h4>Constant and Partial Derivative</h4><p>I have defined a constant &#402;(x) as <br><br> &#402;(x)&#8319; &#8801; &sigma;((&pi;&#183;r&#179;)&#8319;&#8734;)&#8734;<br><br>
The Partial derivative or differential &#8706; of the constant &#402;(x) would be time to leave (point &#402;A), go somewhere (velocity V over time T), and come back (point &#402;B) which is actually A minus B over T&sup3; cubed (third or physical dimension) at rate V, since we always have to be in the present. Returning - <br><br> &#8706;&#402;(x)&#8779;&#402;(&#402;A - &#402;B) / T&sup3;)&#8734; &#8757; <br><br> &#8706;&#402;(x)&#8779;((&#402;A % &#402;B) / &#8704;T)&#8734;<br><br>&#8756; V&#8779;&#8743;&#8744;&#8733;&#8706;&#402;(x)&#8734;</p>
<h4>Past Time</h4><p>
Past time PT is equal to &#8779; the partial &#8706; of the constant &#402;(x) as a remainder % of future time FT over all time &#8704;T exponentially &#8734;. Because the remainder of the future time over all time as a constant gives the past, constantly.<br><br>&#8756;  PT&#8779;((&#8706;&#402;(x) % FT) / &#8704;T)&#8734;</p>
<h4>Future Time</h4>
<p>Future time FT is all time &#8704;T divided over the partial &#8706; of the constant &#402;(x) minus past time PT. Because we have to divide all time &#8704;T over the velocity V and subtract the past to gain the future value as a continuum.<br><br>FT&#8779;((&#8704;T / &#8706;&#402;(x)) - PT)&#8734;</p>
<h4>Time</h4>
<p>Time itself &#8704;T&#8734; is a self reinforcing recurrent function as a composite of past time PT, future time FT divided over the partial derivative of the constant (Velocity) &#8706;&#402;(x) which must then be divided over itself as a summation of the N-Array &#8721; of &#8704;T&#8734; exponentially in all dimensions.<br><br>T&#8779;(((PT + FT) / &#8706;&#402;(x)) / &#8721;&#8704;T&#8734;))&#8734; <br><br>....where x in the aforementioned scenario is....<br><br>&sigma;((&pi;&#183;r&#179;)&#8319;&#8734;)&#8734;</p>
                <h4>Code</h4>
                <pre class="code_div">
                    <code>
float A;
float T;
float C;
float PT;
float FT;
float V;
float PI;
float DIM = 1;
float SIG(C);

//An afterthought
//float DIV;
//float PAR;
//float NTH;
float VEL;
float IN;
float RAD = 1;

//Time goes in recurrently
#define IN T;

//Sigmoid standard is (1 / (1 + E(--z))) where E is the epsilon value or 'frequency'.
#define SIG ((1) / (-1(C--)));

#define PI 3.1415926535;

//Oliptical Dimension
#define A (pow((PI * RAD), DIM));

//Partial derivative
#define V ((PT - FT) / pow(T, 3));

//Partial derivative time matrix
#define VEL [T, V];

//Past Time
#define PT ((C % FT) / T); 

//Constant
#define C (exp(pow(A), ((exp(--IN)) / (exp(IN++))))); //Rate of change or constant from i9.c

//Future Time
#define FT (((T) / C) - PT); 

/* Recursive function gives us the time and constant as a 
 * vector because pT and fT are factored in. T is present, 
 * C is constant rate of change (defined) thus, the present. */

#define T (exp(((PT + FT) / VEL) / (pow(exp(VEL))), (exp(IN, DIM))))); 

float main (float argc, char **argv) {
    return 1;
}
                    </code>
                </pre>
            </div>
        </article>
        <article>
            <div>
                <h3><a href="https://github.com/russellclarke82/QBit-and-GParticulates" target="_blank">LandRover</a></h3>
                <p>Simply a play on words to describe a simple logic for engine on engine off processes in an ICU (could be any ICU) without importing navigation headers and without exporting data to a server.<br><br> Just a quick 15 minute write up after a Bluetooth name flagged up on my phone when I was messing with it. I thought, hmmmm, I could write some code for that.<br><br></p>
                <h4>Code</h4>
                <pre class="code_div">
                    <code>
float L;
float A;
float N;
float D = 3;
float R = 1;
float O;
float V;
float E;
float PI;
unsigned char report;

//location lon lat distance
float L1;
float L2;
float L3;

float main() {
    int engine, off = 0, on = 1;

    report = L++, L1++, L2++, L3++;

    engine = (0 != 1) ? 0 : 1;

    //lon and lat header files required here
    L = 0.000000; //distance set to zero
    L1 = 0.000000; //lon  
    L2 = 0.000000; //lat
    #define L3 = (-L1, -L2); //Get an invert for accuracy.
    #define A (pow((PI * R), D));
    #define N (pow(L, A)); //Distance in the Nth Dimension;
    #define O (/* id comprised of VIN, MAC, ICU, REG? */);
    #define V (L / E);
    #define E diff(time_t go, time_t stop);

    report;

    if(1){
        time_t go;
        report;
    }else if(0){
        time_t stop;
        report;
    }
    
    return 0;
}
                    </code>
                </pre>
            </div>
        </article>
        <article>
            <div>
                <h3><a href="https://github.com/russellclarke82/RTL" target="_blank">RTL Project Merge</a></h3>
                <p>This project is a merger from the 'Thyme' and 'QBit and GParticulates' repositories. It combines the back propagation reinforcement learning algorithms in i9.c and the probability calculations which make use of decision tables and the Markov Decision Process with the theorem of time.<br><br>Apologies in advance for the hybrid of Math with functional programming in the notation. The purpose is to try to get an accurate probability over time by calculations and learning constantly from the partial derivative VEL which is a Matrix of time T and differential V.<br><br>It is still a work in progress since it is theorem. Without further adieu, in order of build;</p><h3>Decision Tables, MDP and QuBit</h3><p>The first port of call is to pay tribute once again to decisions tables, Markov Decision Process and AI, I learnt about them at University.</p><h4>Decision Tables and probability</h4><p>Factoring in probability into a decision table was a concept I considered when thinking about QuBit logic.<br><br>Using basic knowledge of the <a href="https://www.wikipedia.org/wiki/Markov_decision_process" target="_blank">Markov Decision Process</a>, I think I may have implemented it correctly within the decision table. I do not recommend Wikipedia for academic work however, as a quick reference or refresher it can be useful for a brief overview.<br><br>I defined Y as equivalent to a boolean value of 1 &#8893; (one or the other) 0. The way I think a QuBit works logically, would be to calculate the probability of either 1 &#8893; 0 over all input (input prime or J'), squared &sup2;; Since the decision table always has two possible decisions. Adding the logical boolean Y of 1 &#8893; 0 brings consideration of the input for all &#8704; values being either on or off (1 or 0) at any one given moment as part of the function.<br><br> This brings us to MDP. Even though QuBits consider both outputs simultaneously such that P(A&#8745;B) and P(A&#8746;B) are both simultaneously parallel &#8741;, a similar process can be emulated using increments of the input as a data stream. As such, I ended up with the function - <br><br>Y &#8779; 1 &#8893; 0<br><br>J &#8779; Y &#8704; Y&#8734;<br><br>P | J' &#8779; MDP<br><br>Q &#8779; ((((P | J')&#8319;&#8734;)&sup2;)+Y)&#8734;</p><h3>Weights and Biases</h3><p>When defining the weights and biases, they had to be defined as random in each instance or iteration for several reasons, it is my opinion, probability systems should have a bias but it should be random to provide the best probable outcome based on what information it is receiving as a constant.<br><br>Personally I don't think they should have a strong bias in one favour or the other unless in the instance of law, health (including environment) and possibly economics. However for Math, deterministic probable outcome would be best achieved using a constant random bias, which explains why I have not chosen to update the bias or the weights. They are generated randomly each time for each iteration. Potentially, that would provide a more accurate outcome rather than a biased one.<br><br>The other, of course is to distribute the weights as a mean average deviation  (Find the median, calculate the lowest average and the highest average) accordingly, across all perceptrons as per discussion in <a href="https://www.neuralnetworksanddeeplearning.com/chap1.html" target="_blank">Neural Networks and Deep Learning Article</a>.<br><br>The weights and biases are distributed as random float values using modf() and rand() function in C, the minimum and maximum values are set to 0.0 and 1.0 where the returned values are randomly generated and are greater than or equal to &#8805; 0.0 and less than or equal to &#8804; 1.0, discarding the integer values into memory location across all perceptrons. The weights and bias are defined respectively as - <br><br>W&#8779;&phi;(x)&#8704;W&#8319;&#8734;<br><br>B&#8779;&phi;(x)&#8704;B&#8319;&#8734;</p><h3>MDP</h3><p>Redefining the <a href="https://www.wikipedia.org/wiki/Markov_decision_process" target="_blank">MDP</a> to suit this project was quite a challenge, as already mentioned, a suitable input method was required for the probability and reward functions, the bias, weights (as part of the DNN) and collate them into the MDP ready for the decision tables.</p><h5>Rewards</h5><p>Defining the reward had to be done using the logical operator Y and factor in any input (more on that later) which might be entering the DNN and MDP. The reward was defined as 1 &#8893; 0 divided / over the vector matrix INPUT(T, V, O) of <br><br>Time <br><br>T&#8779;(((PT + FT) / &#8706;&#402;(x)) / &#8721;&#8704;T&#8734;))&#8734;<br><br>Velocity as a partial derivative<br><br> V&#8779;&#8743;&#8744;&#8733;&#8706;&#402;(x)&#8734;<br><br> and Output (as a full back propagation from the DNN output not yet implemented), across all iterations &#8704;N(T,V,O) exponentially &#8734;; As such the reward value could be defined as - <br><br>R&#8779;((Y&#8779;1 &#8893; 0)/((T&#8779;(((PT + FT) / &#8706;&#402;(x)) / &#8721;&#8704;T&#8734;))&#8734;, V&#8779;&#8743;&#8744;&#8733;&#8706;&#402;(x)&#8734;, OUTPUT, OUT)&#8734;))&#8734;<br><br>or simply<br><br>R&#8779;(Y / (&#8706;T, (&#8704;T, &#8704;V, &#8704;OUTPUT, &#8706;OUTPUT))&#8734;<br><br>...more on the outputs later.</p><h5>Probability</h5><p>The probability P is measured over an exponential vector matrix of N INPUT * weights W and the original bias B&#8779;&phi;(x)&#8704;B&#8319;&#8734; then divided over the matrix of partial input V and bias B exponentially. As such the probability P could be noted as -<br><br>P&#8779;((N&#8779;((T&#8779;(((PT + FT) / &#8706;&#402;(x)) / &#8721;&#8704;T&#8734;))&#8734;, V&#8779;&#8743;&#8744;&#8733;&#8706;&#402;(x)&#8734;, OUTPUT, OUT)&#8734;) / (V&#8779;&#8743;&#8744;&#8733;&#8706;&#402;(x)&#8734;, Y&#8779;1 &#8893; 0))&#8734;<br><br>or simply<br><br>P&#8779;((&#8704;T, &#8704;V, &#8704;OUTPUT, &#8706;OUTPUT)&#8734; / (&#8706;V, Y))&#8734;</p><h5>MDP</h5><p>The MDP of some event is measured over an exponential vector matrix of time T with a partial differential of &#8706;T as velocity VEL and the OUTPUT (defined later) where velocity V is the action in the state space time T and the event is Y occurring in multiple states over T with the reward values and biases being distributed back through the network for reassessment. <br><br>The vector is divided over the reward R and bias B continuously to feed forward and back propagate into the network at a median level. The resulting function is - <br><br>MDP&#8779;((T&#8779;(((PT + FT) / &#8706;&#402;(x)) / &#8721;&#8704;T&#8734;))&#8734;, V&#8779;&#8743;&#8744;&#8733;&#8706;&#402;(x)&#8734;, OUTPUT)&#8734;) / R&#8779;((1 &#8893; 0)/((T&#8779;(((PT + FT) / &#8706;&#402;(x)) / &#8721;&#8704;T&#8734;))&#8734;, V&#8779;&#8743;&#8744;&#8733;&#8706;&#402;(x)&#8734;, OUTPUT, OUT)&#8734;))&#8734; + B&#8779;&phi;(x)&#8704;B&#8319;&#8734;)&#8734;<br><br>The logic of Q is then questioned again by implementing the same MDP in 'R' and in it's own probability decision making, where 'R' is as MDP (Q / (REWARD + BIAS)) (please see code). The most likely behaviour is the AI decides 1 is more probable and preferred over 0 since 0 would be off preventing it from doing what it does, think and solve problems.</p>
            <h4>Code</h4>
                <pre class="code_div">                    
                    <code>                    
float A;
float T;
float C;
float PT;
float FT;
float V;
float PI;
float DIM;
float SIG(C);
float VEL;
float IN;
float RAD = 1;

float WEIGHT;
float weights;
float EPSILON;
float SIGMOID(O);
float COST;
float BIAS;
float REWARD;
float PROBABILITY;
float MDP;
float Q;
float R;
float INPUT;
float HIDDEN;
float OUTPUT;

float main () {

    #define IN T;
    #define SIG ((1) / (-1(C--)));
    #define PI 3.1415926535;
    #define A (pow((PI * RAD), DIM));
    #define V ((PT - FT) / pow(T, 3));
    #define VEL [T, V];
    #define PT ((C % FT) / T); 
    #define C exp(pow(A), ((exp(--IN)) / (exp(IN++))));
    #define FT (((T) / C) - PT); 
    #define T exp(((PT + FT) / VEL) / (pow(exp(VEL))), (exp(IN, DIM))));

    #define WEIGHT modf(((randn() % 1.0) + 0.0), float *wdiscard);
    #define EPSILON 5E-5;
    #define SIGMOID(O) (1.0 / (-1 + (exp(O)--))));

    #define GRAD_DESCENT pow(((COST) - (COST(EPSILON))), 2);
    #define COST (weights, BIAS);
    #define BIAS modf(((randn() % 1.0) + 0.0), float *bdiscard);
    #define N INPUT++;
    #define OUT SIGMOID((weights * N) + BIAS);
    #define Y (0 ?: 1);
    #define REWARD (Y / (INPUT, N));
    #define PROBABILITY (N / (INPUT, Y));
    #define MDP (PROBABILITY / (REWARD + BIAS));
    #define Q pow(pow(MDP, N), 2) + Y;
    #define R (Q / (REWARD + BIAS));

    #define INPUT (SIG, OUT, OUTPUT, VEL) * WEIGHT) + BIAS;
    #define HIDDEN ((SIG. OUT, OUTPUT, VEL) * (10 * pow(20, 4))) * WEIGHT;
    #define OUTPUT (4 * WEIGHT) + BIAS;
    
    return 1;
}
                    </code>
                </pre>
            </div>
        </article>
    </content>
</content>
<footer><a href="index.html" target="_self" class="footer_links">Home</a>      <a href="httpS://www.github.com/russellclarke82" target="_self" class="footer_links">GitHub Repositories</a></footer>
</body>
</html>
